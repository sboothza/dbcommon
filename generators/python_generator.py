import glob
import os
import shutil
from pathlib import Path
from typing import List

from adaptors.adaptor import Adaptor
from database_objects import Table, Field, FieldType, QueryType, KeyType, Database
from generators.generator import Generator
from naming import Naming, Name
from source_writer import SourceWriter


class PythonGenerator(Generator):
    def __init__(self, naming: Naming):
        super().__init__(naming)

    def get_filename(self, name: Name, prefix: str = "", suffix: str = "") -> str:
        return name.snake(prefix, suffix) + ".py"

    def copy_templates(self, template_folder: str, output_folder: str):
        template_folder = os.path.join(template_folder, "python")
        output_folder = os.path.join(output_folder, "base")
        dir_path = os.path.join(template_folder, "*.txt")
        for file in glob.glob(dir_path):
            filename = Path(file).stem
            new_filename = os.path.join(output_folder, filename + ".py")
            shutil.copy(file, new_filename)

    @staticmethod
    def read_custom_code(filename: str) -> List[str]:
        custom_code: List[str] = []
        if os.path.exists(filename):
            with open(filename, 'r') as reader:
                have_marker = False
                line = reader.readline()
                while line:
                    line = line.replace("\n", "")
                    if have_marker:
                        custom_code.append(line)
                    elif "# end-autogenerated" in line:
                        have_marker = True

                    line = reader.readline()
                reader.close()
        return custom_code

    def generate_entity(self, table: Table, database: Database, filename: str, adaptor: Adaptor, naming: Naming):
        # find custom code
        custom_code = PythonGenerator.read_custom_code(filename)

        with SourceWriter(open(filename, 'w')) as writer:
            writer.writeln("from datetime import datetime")
            writer.writeln("from typing import List")
            writer.writeln("from base.table_base import TableBase")
            for key in table.foreign_keys:
                ref_table = database.get_table(key.referenced_table)
                writer.writeln(f"from entities.{ref_table.name.snake()} import {ref_table.name.pascal()}")

            for key in [k for k in table.keys if k.key_type == KeyType.Lookup]:
                ref_table = database.get_table(key.primary_table)
                writer.writeln(f"from entities.{ref_table.name.snake()} import {ref_table.name.pascal()}")

            writer.writeln()
            writer.writeln()
            writer.writeln(f"class {table.name.pascal()}(TableBase):")
            writer.indent()
            writer.writeln(f"__table_name__ = \"{table.name.raw()}\"")
            writer.writeln(f"__drop_script__ = \"{adaptor.generate_drop_script(table)}\"")
            writer.writeln(f"__create_script__ = \"{adaptor.generate_create_script(table)}\"")
            writer.writeln(
                f"__table_exists_script__ = \"{adaptor.generate_table_exists_script(table, database.name.raw())}\"")
            writer.writeln(f"__table_count_script__ = \"{adaptor.generate_count_script(table)}\"")
            writer.writeln(f"__insert_script__ = \"{adaptor.generate_insert_script(table)}\"")
            writer.writeln(f"__update_script__ = \"{adaptor.generate_update_script(table)}\"")
            writer.writeln(f"__delete_script__ = \"{adaptor.generate_delete_script(table)}\"")
            writer.writeln(f"__fetch_by_id_script__ = \"{adaptor.generate_fetch_by_id_script(table)}\"")
            writer.writeln(f"__item_exists_script__ = \"{adaptor.generate_item_exists_script(table)}\"")
            writer.writeln()
            self.generate_fields(table, database, writer, naming)
            self.generate_init(table, writer, database, naming)
            writer.writeln()
            self.generate_mapper(table, writer, adaptor)
            writer.writeln()
            self.generate_get_params(table, writer, adaptor)
            writer.unindent()
            writer.writeln("# end-autogenerated")

            for line in custom_code:
                writer.writeln(line)

    @staticmethod
    def get_python_field_type(field: Field) -> str:
        if field.type == FieldType.String:
            return "str"
        elif field.type == FieldType.Integer:
            return "int"
        elif field.type == FieldType.Float:
            return "float"
        elif field.type == FieldType.Decimal:
            return "float"
        elif field.type == FieldType.Boolean:
            return "bool"
        elif field.type == FieldType.Datetime:
            return "datetime"
        else:
            raise Exception("Field type invalid")

    @staticmethod
    def get_python_default_value(field: Field) -> str:
        if field.type == FieldType.String:
            return f"\"{field.default}\""
        elif field.type == FieldType.Integer or field.type == FieldType.Float or field.type == FieldType.Decimal:
            return f"{'0' if field.default is None else field.default}"
        elif field.type == FieldType.Boolean:
            return f"{'False' if field.default is None or field.default == '0' else 'True'}"
        elif field.type == FieldType.Datetime:
            return "datetime.min"
        else:
            raise Exception("Field type invalid")

    def generate_fields(self, table: Table, database: Database, writer: SourceWriter, naming: Naming):
        for field in table.fields:
            writer.writeln(
                f"{field.name.snake()}: {self.get_python_field_type(field)} = {self.get_python_default_value(field)}")

            # lookups
        writer.writeln()
        for lookup in [key for key in table.keys if key.key_type == KeyType.Lookup]:
            primary_table = naming.string_to_name(lookup.primary_table)
            writer.writeln(f"{primary_table.snake()}: {primary_table.pascal()} #{lookup.name.raw()}")

        # fk's

        for foreign_key in table.foreign_keys:
            foreign_table = database.get_table(foreign_key.referenced_table)
            writer.writeln(
                f"{foreign_table.name.snake()}: List[{foreign_table.name.pascal()}] # {foreign_key.name.raw()}")

        writer.writeln()

    def generate_init(self, table: Table, writer: SourceWriter, database: Database, naming: Naming):
        param_list = ["self"]
        for field in table.fields:
            param_list.append(
                f"{field.name.snake()}: {self.get_python_field_type(field)} = {self.get_python_default_value(field)}")
        writer.writeln(f"def __init__({', '.join(param_list)}):")
        writer.indent()
        for field in table.fields:
            writer.writeln(f"self.{field.name.snake()} = {field.name.snake()}")

        for lookup in [key for key in table.keys if key.key_type == KeyType.Lookup]:
            primary_table = naming.string_to_name(lookup.primary_table)
            writer.writeln(f"self.{primary_table.snake()} = None")

        for foreign_key in table.foreign_keys:
            foreign_table = database.get_table(foreign_key.referenced_table)
            writer.writeln(f"self.{foreign_table.name.snake()}: List[{foreign_table.name.pascal()}] = list()")

        writer.unindent()

    @staticmethod
    def get_remapper(from_field_type: FieldType, to_field_type: FieldType, item: str) -> str:
        if from_field_type == FieldType.Boolean and to_field_type == FieldType.Integer:
            return f"TableBase.bool_to_int({item})"
        elif from_field_type == FieldType.Integer and to_field_type == FieldType.Boolean:
            return f"TableBase.int_to_bool({item})"
        elif from_field_type == FieldType.Datetime and to_field_type == FieldType.Float:
            return f"TableBase.datetime_to_float({item})"
        elif from_field_type == FieldType.Float and to_field_type == FieldType.Datetime:
            return f"TableBase.float_to_datetime({item})"
        else:
            raise Exception("Unknown field type ")

    def generate_mapper(self, table: Table, writer: SourceWriter, adaptor: Adaptor):
        writer.writeln("def map_row(self, row) -> TableBase:")
        writer.indent()
        for i in range(len(table.fields)):
            value = f"row[{i}]"
            must_remap, to_type = adaptor.must_remap_field(table.fields[i].type)
            if must_remap:
                value = self.get_remapper(to_type, table.fields[i].type, value)

            writer.writeln(f"self.{table.fields[i].name.snake()} = {value}")

        writer.writeln("return self")

        writer.unindent()

    def generate_get_params(self, table: Table, writer: SourceWriter, adaptor: Adaptor):
        writer.writeln("def get_insert_params(self) -> {}:")
        writer.indent()
        writer.writeln(
            f"return {self.build_param_dict_from_item([f for f in table.fields if not f.auto_increment], adaptor)}")
        writer.unindent()
        writer.writeln()

        writer.writeln("def get_update_params(self) -> {}:")
        writer.indent()
        params = [f for f in table.fields if f.name.name not in table.pk.fields] + \
                 [f for f in table.fields if f.name.name in table.pk.fields]
        writer.writeln(f"return {self.build_param_dict_from_item(params, adaptor)}")
        writer.unindent()
        writer.writeln()

    def build_param_array_types(self, fields: [Field], prefix=None, suffix=None) -> []:
        if prefix is None:
            prefix = []
        if suffix is None:
            suffix = []
        param_list = prefix + [f"{field.name.snake()}: {self.get_python_field_type(field)}" for field in
                               fields] + suffix
        param_strs = [p for p in param_list if p != ""]
        return param_strs

    def build_param_dict_from_item(self, fields: [Field], adaptor: Adaptor, prefix=None, suffix=None) -> str:
        if suffix is None:
            suffix = []
        if prefix is None:
            prefix = []
        param_list = [] + prefix
        for field in fields:
            value = f"self.{field.name.snake()}"
            must_remap, to_field = adaptor.must_remap_field(field.type)
            if must_remap:
                value = self.get_remapper(field.type, to_field, value)
            param_list.append(f"\"{field.name.raw()}\": {value}")

        param_list = param_list + suffix
        param_strs = [p for p in param_list if p != ""]
        return f"{{{', '.join(param_strs)}}}"

    def build_param_dict_from_params(self, fields: [Field], adaptor: Adaptor, prefix=None, suffix=None) -> str:
        if suffix is None:
            suffix = []
        if prefix is None:
            prefix = []
        param_list = [] + prefix
        for field in fields:
            value = "{name}".format(name=field.name.snake())
            must_remap, to_field = adaptor.must_remap_field(field.type)
            if must_remap:
                value = self.get_remapper(field.type, to_field, value)
            param_list.append(f"\"{field.name.raw()}\": {value}")

        param_list = param_list + suffix
        param_strs = [p for p in param_list if p != ""]
        return f"{{{','.join(param_strs)}}}"

    def generate_repository(self, table: Table, database: Database, filename: str, adaptor: Adaptor, naming: Naming):
        # find custom code
        custom_code = self.read_custom_code(filename)

        with SourceWriter(open(filename, 'w')) as writer:
            writer.writeln("from datetime import datetime")
            writer.writeln("from typing import Optional")
            writer.writeln()
            writer.writeln("from base.table_base import TableBase")
            writer.writeln("from base.session import Session")
            writer.writeln("from base.repository_base import RepositoryBase")
            writer.writeln("from config import Config")
            writer.writeln(f"from entities.{table.name.snake()} import {table.name.pascal()}")

            references = [key for key in table.keys if key.key_type == KeyType.Lookup] + table.foreign_keys
            for ref in references:
                if ref.key_type == KeyType.ForeignKey:
                    ref_table = naming.string_to_name(ref.referenced_table)
                else:
                    ref_table = naming.string_to_name(ref.primary_table)
                writer.writeln(
                    f"from repositories.{ref_table.snake()}_repository import {ref_table.pascal()}Repository")
            writer.writeln()
            writer.writeln()
            writer.writeln(f"class {table.name.pascal()}Repository(RepositoryBase):")
            writer.indent()
            writer.writeln(f"__table__ = {table.name.pascal()}")
            # writer.writeln()

            ref_list = []
            for ref in references:
                if ref.key_type == KeyType.ForeignKey:
                    ref_table = naming.string_to_name(ref.referenced_table)
                else:
                    ref_table = naming.string_to_name(ref.primary_table)
                ref_list.append(ref_table)

            for ref_table in ref_list:
                writer.writeln(f"{ref_table.snake()}_repo: {ref_table.pascal()}Repository")

            params = ["self"] + [f"{ref_table.snake()}_repo: {ref_table.pascal()}Repository"]
            writer.writeln()
            writer.writeln(f"def __init__({', '.join(params)}):")
            writer.indent()
            for ref_table in ref_list:
                writer.writeln(f"self.{ref_table.snake()}_repo = {ref_table.snake()}_repo")
            writer.writeln()
            writer.unindent()

            repo_param_list: List[str] = ["self"]
            repo_init_list: List[str] = []
            for ref in references:
                if ref.key_type == KeyType.ForeignKey:
                    ref_table = naming.string_to_name(ref.referenced_table)
                else:
                    ref_table = naming.string_to_name(ref.primary_table)
                repo_param_list.append(f"{ref_table.snake()}_repo: {ref_table.pascal()}Repository")
                repo_init_list.append(f"self.{ref_table.snake()}_repo = {ref_table.snake()}_repo")

            # writer.writeln(f"def bind({', '.join(repo_param_list)}):")
            # writer.indent()
            #
            # for init in repo_init_list:
            #     writer.writeln(init)
            # if len(repo_init_list) == 0:
            #     writer.writeln("pass")

            # writer.unindent()
            # writer.writeln()

            f_list = [table.find_field(pk_field) for pk_field in table.pk.fields]
            param_list = self.build_param_array_types(f_list, ["self", "session: Session"])
            writer.writeln(f"def get_by_id({', '.join(param_list)}):")
            writer.indent()
            writer.writeln(f"item: {table.name.pascal()} = self._get_by_id(session, "
                           f"{self.build_param_dict_from_params(f_list, adaptor)})")

            for key in [key for key in table.keys if key.key_type == KeyType.Lookup]:
                ref_table = naming.string_to_name(key.primary_table)
                params = [f"item.{naming.string_to_name(field).snake()}" for field in key.fields]
                writer.writeln(f"item.{ref_table.snake()} = self.{ref_table.snake()}"
                               f"_repo.get_by_id(session, {', '.join(params)})")

            for ref in table.foreign_keys:
                ref_table = naming.string_to_name(ref.referenced_table)
                ref_pk_list = ["item.{field_name}".format(field_name=naming.string_to_name(f).snake()) for f in
                               ref.primary_fields]
                writer.writeln(f"item.{ref_table.snake()} = self.{ref_table.snake()}_repo.get_for_{table.name.snake()}"
                               f"(session, {', '.join(ref_pk_list)})")

            writer.writeln("return item")
            writer.writeln()
            writer.unindent()
            writer.writeln(f"def exists({', '.join(param_list)}):")
            writer.indent()
            writer.writeln(f"return self._item_exists(session, {self.build_param_dict_from_params(f_list, adaptor)})")
            writer.writeln()
            writer.unindent()
            writer.writeln(f"def delete({', '.join(param_list)}):")
            writer.indent()
            writer.writeln(f"self._delete(session, {self.build_param_dict_from_params(f_list, adaptor)})")
            writer.writeln()
            writer.unindent()
            writer.writeln(f"def add(self, session: Session, item: {table.name.pascal()}):")
            writer.indent()

            if len(f_list) == 1 and f_list[0].auto_increment:
                writer.writeln(f"{f_list[0].name.snake()} = self._execute_lastrowid(session, item.__insert_script__, "
                               f"item.get_insert_params())")
                writer.writeln(f"item.{f_list[0].name.snake()} = {f_list[0].name.snake()}")
            else:
                writer.writeln("self._execute(session, item.__insert_script__, item.get_insert_params())")

            for ref in table.foreign_keys:
                ref_table = naming.string_to_name(ref.referenced_table)
                writer.writeln(f"for {ref_table.snake()} in item.{ref_table.snake()}:")
                writer.indent()
                for i in range(len(ref.fields)):
                    key_field = naming.string_to_name(ref.fields[i])
                    ref_field = naming.string_to_name(ref.primary_fields[i])

                    writer.writeln(f"{ref_table.snake()}.{key_field.snake()} = {ref_field.snake()}")
                writer.unindent()
                writer.writeln(f"self.{ref_table.snake()}_repo.add(session, {ref_table.snake()})")

            writer.unindent()
            writer.writeln()

            for custom_query in table.custom_queries:
                query = custom_query.query.replace("__table_name__", table.name.raw())
                query = adaptor.replace_parameters(query)

                params = [parameter for parameter in custom_query.parameters]

                writer.writeln(f"def {custom_query.name.snake()}("
                               f"{', '.join(['self', 'session: Session'] + [p.name.snake() for p in params])}):")
                writer.indent()
                if custom_query.query_type == QueryType.Execute:
                    writer.writeln(f"self._execute(session, \"{query}\", "
                                   f"parameters={self.build_param_dict_from_params(params, adaptor)})")
                elif custom_query.query_type == QueryType.FetchScalar:
                    writer.writeln(f"return self._fetch_scalar(session, \"{query}\", "
                                   f"parameters={self.build_param_dict_from_params(params, adaptor)})")
                elif custom_query.query_type == QueryType.FetchOne:
                    writer.writeln(f"result = self.fetch_one(session, \"{query}\", "
                                   f"parameters={self.build_param_dict_from_params(params, adaptor)})")
                    writer.writeln("return result")
                elif custom_query.query_type == QueryType.FetchAll:
                    writer.writeln(f"result = self.fetch(session, \"{query}\", "
                                   f"parameters={self.build_param_dict_from_params(params, adaptor)})")
                    writer.writeln("return result")
                else:
                    raise Exception("Unknown query type")

            writer.writeln()
            # get foreign keys
            for foreign_key in [key for key in table.keys if key.key_type == KeyType.ForeignKey]:
                primary_table = database.get_table(foreign_key.primary_table)
                fields = [naming.string_to_name(f).snake() for f in foreign_key.fields]
                writer.writeln(f"def get_for_{primary_table.name.snake()}(self, session: Session, {','.join(fields)}):")
                writer.indent()
                fields = [f"`{f.name.raw()}`" for f in primary_table.fields]
                params = [f"`{f}` = %({f})s" for f in primary_table.pk.fields]
                writer.writeln(f"result = self.fetch(session, \"select {', '.join(fields)} from `{primary_table.name.raw()}` "
                               f"where {' and '.join(params)};\")")
                writer.writeln("return result")
                writer.unindent()
                writer.writeln()

            writer.unindent()
            writer.writeln()
            writer.writeln("# end-autogenerated")

            for line in custom_code:
                writer.writeln(line)
